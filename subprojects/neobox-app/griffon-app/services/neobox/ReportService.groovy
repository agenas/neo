/*
 * Copyright 2014 Stefano Gualdi, AGENAS.
 *
 * Licensed under the European Union Public Licence (EUPL), Version 1.1 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://joinup.ec.europa.eu/software/page/eupl/licence-eupl
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package neobox

import org.apache.commons.io.IOUtils
import org.apache.commons.io.FileUtils
import org.apache.commons.lang.StringEscapeUtils
import org.apache.commons.lang.time.StopWatch

import java.io.FileOutputStream
import java.io.InputStream
import neobox.utils.NeoboxUtils
import com.google.code.docbook4j.renderer.PDFRenderer
import groovy.text.*

/**
 * @author Stefano Gualdi <stefano.gualdi@gmail.com>
 */

class ReportService {
	def runReportGeneration(List indicators, Map runningParams, File indicatorsDir, File workDir) {
        StopWatch timer = new StopWatch()
        timer.start()

        if (indicators.size() == 0) {
            return
        }

        log("Report generation start", 'info')

        app.event('ReportGenerationStarted', [indicators.size() + 1])

        try {
            File reportWorkDir = new File(workDir, 'report')
            if (!reportWorkDir.exists()) {
                reportWorkDir.mkdirs()
            }

            def xmlEngine = new XmlTemplateEngine()

            // Prepare chapter template
            def chapterTmplFile = new File(indicatorsDir, "report/chapter.xml")
            def chapterTmpl = xmlEngine.createTemplate(chapterTmplFile)

            def cleanupList = []

            // Collect all chunks to generate the final docbook xml file
            def chunks = []
            for (i in indicators) {
                if (!i.excludeReport) {
                    log("Processing indicator ${i.id}")

                    def indicatorOutputDir = new File(workDir, i.id)

                    // Read the chunk generated by R code
                    def reportChunkFile = new File(indicatorOutputDir, "report.xml")
                    if (reportChunkFile.exists()) {
                        def binding = [
                            id: i.id,
                            title: i.description,
                            body: reportChunkFile.text
                        ]
                        chunks << chapterTmpl.make(binding).toString()

                        // Copy all files generated by R to the report work dir
                        indicatorOutputDir.eachFile { f ->
                            if (NeoboxUtils.splitFilename(f.name).ext in ['pdf', 'jpg', 'gif', 'png']) {
                                FileUtils.copyFileToDirectory(f, reportWorkDir)
                                cleanupList << new File(reportWorkDir, f.name)
                            }
                        }
                    }
                    app.event('ReportGenerationProgress')
                }
            }

            // Prepare the master template
            def masterTmplFile = new File(indicatorsDir, "report/master.xml")
            def masterTmpl = xmlEngine.createTemplate(masterTmplFile)

            // Copy all resources in reportWorkDir
            def sourceResourcesDir = new File(indicatorsDir, "report/resources")
            if (sourceResourcesDir.exists()) {
                def destResourcesDir = new File(reportWorkDir, "resources")
                if (!destResourcesDir.exists()) {
                    destResourcesDir.mkdirs()
                }
                FileUtils.copyDirectory(sourceResourcesDir, destResourcesDir)
                cleanupList << destResourcesDir
            }

            // Compile all chunks into the final docbook report file
            def now = new Date()
            def metadata = [
                timestamp: now.format("dd-MM-yyyy HH:mm:ss")
            ]
            runningParams.each { k, v ->
                if (v instanceof String) {
                    metadata[k] = StringEscapeUtils.escapeXml(v)
                }
                else {
                    metadata[k] = v
                }
            }

            def binding = [
                metadata: metadata,
                body: chunks.join('\n')
            ]
            def finalDocbookXml = masterTmpl.make(binding).toString()

            File reportFile = new File(reportWorkDir, "report.xml")
            reportFile.withWriter("UTF-8") { it << finalDocbookXml }

            cleanupList << reportFile

            // Prepare the renderer
            String xml = "file:${reportFile.absolutePath}"
            File xslFile = new File(indicatorsDir, "report/master.xsl")
            String xsl = "file:${xslFile.absolutePath}"

            log("Rendering PDF file")

            // Render the final PDF report
            PDFRenderer pdfRenderer = PDFRenderer.create(xml, xsl)
    		File outfile = new File(reportWorkDir, "report.pdf")
    		writeToFile(pdfRenderer.render(), outfile)

            // Cleanup temp files
            cleanupList.each { f ->
                f.file ? f.delete() : f.deleteDir()
            }

            app.event('ReportGenerationFinished')
        }
        catch(Exception e) {
            app.event('ReportGenerationError')
            log("Rendering PDF file", 'error', true)
            log.error e.message, e
        }

        timer.stop()

        log("Report generation end in ${timer.toString()}", 'complete')
    }

    def writeToFile(InputStream inStream, File outfile) {
        FileOutputStream out = new FileOutputStream(outfile)
        long count = IOUtils.copyLarge(inStream, out)
        out.close()
        inStream.close()
    }

    private void log(String msg, String type = "", boolean consoleOnly = false) {
        app.event('WriteLog', [msg, type])
        if (!consoleOnly) {
            log.debug msg
        }
    }
}
